#!/usr/bin/perl -w
use File::Copy;
use File::Path;
use Version::Util qw(cmp_version);
use strict;

-e 'build' or die "This script must be run from within its own directory";

my $dryrun = 0;

my $imagetype=$ARGV[0];
my $release=$ARGV[1];
if (not ($release and $imagetype)) {
    print <<__END__;
Usage: ./build <imagetype> <release> [<arch>]

Examples:
    ./build basic 39
    ./build desktop bookworm i386
    ./build pkgdev jammy
    ./build pkgdev-doxygen 15.5
    ./build regina sid
    ./build regina-7.0 bullseye
__END__
    exit 1;
}

# Some globals for our helper functions:
my $hasAddedRepo = 0;
my %debianVersion = (
    'woody' => 3.0, 'sarge' => 3.1,
    'etch' => 4, 'lenny' => 5, 'squeeze' => 6, 'wheezy' => 7,
    'jessie' => 8, 'stretch' => 9, 'buster' => 10, 'bullseye' => 11,
    'bookworm' => 12, 'trixie' => 13, 'forky' => 14,
    'sid' => 999 );
my %ubuntuVersion = (
    'warty' => '4.10', 'hoary' => '5.04', 'breezy' => '5.10',
    'dapper' => '6.06', 'edgy' => '6.10', 'feisty' => '7.04',
    'gutsy' => '7.10', 'hardy' => '8.04', 'intrepid' => '8.10',
    'jaunty' => '9.04', 'karmic' => '9.10', 'lucid' => '10.04',
    'maverick' => '10.10', 'natty' => '11.04', 'oneiric' => '11.10',
    'precise' => '12.04', 'quantal' => '12.10', 'raring' => '13.04',
    'saucy' => '13.10', 'trusty' => '14.04', 'utopic' => '14.10',
    'vivid' => '15.04', 'wily' => '15.10', 'xenial' => '16.04',
    'yakkety' => '16.10', 'zesty' => '17.04', 'artful' => '17.10',
    'bionic' => '18.04', 'cosmic' => '18.10', 'disco' => '19.04',
    'eoan' => '19.10', 'focal' => '20.04', 'groovy' => '20.10',
    'hirsute' => '21.04', 'impish' => '21.10', 'jammy' => '22.04',
    'kinetic' => '22.10', 'lunar' => '23.04', 'mantic' => '23.10',
    'noble' => '24.04' );

my @alldists = qw(debian ubuntu fedora opensuse arch);
my $dist;
foreach my $d (@alldists) {
    open(LIST, '<', "../supported/$d.list") or die;
    while (<LIST>) {
        chomp;
        if ($_ eq $release) {
            $dist = $d;
            last;
        }
    }
    close(LIST);
    defined $dist and last;
}
defined $dist or die "Not a release from a known distribution: $release";
print("Distribution: $dist\n");

# $arch = the architecture that was explicitly selected; may be undefined.
# $usearch = the architecture that the guest machine is using; always defined.
# TODO: Squash the possible values down to x86_64, aarch64, i386.
my $arch = $ARGV[2];
my $relarch = $release;
my $usearch = $arch;
if (defined $arch) {
    print("Architecture: $arch\n");
    $relarch .= "_$arch";
} else {
    $usearch = `uname -m`;
    chomp $usearch;
    print("Architecture: same as host ($usearch)\n");
}

my $context = "${imagetype}_${dist}_${relarch}";
-e $context and die "Stale directory needs to be removed: $context";
mkdir $context or die;

my $dockerfile = "${imagetype}_${dist}_${relarch}.Dockerfile";
my $dockerdata;
if ($imagetype eq 'basic') {
    $dockerdata = basic();
} elsif ($imagetype eq 'desktop') {
    $dockerdata = desktop();
} elsif ($imagetype eq 'pkgdev') {
    $dockerdata = pkgdev();
} elsif ($imagetype =~ /^pkgdev-([a-z0-9]+)$/) {
    $dockerdata = pkgdev($1);
} elsif ($imagetype eq 'regina') {
    $dockerdata = regina();
} elsif ($imagetype =~ /^regina-([0-9.]+)$/) {
    $dockerdata = regina($1);
} elsif ($imagetype eq 'archive') {
    $dockerdata = archive();
} else {
    die "Unknown image type: $imagetype";
}
defined $dockerdata or die "This specific docker image is not yet supported";

print("\nWriting $dockerfile...\n");
open(DOCKERFILE, '>', $dockerfile) or die;
print DOCKERFILE $dockerdata;
close(DOCKERFILE);

my $tag = ($dist eq 'arch' ? "$imagetype/$dist" : "$imagetype/$dist:$relarch");
print("Building $tag...\n\n");

if ($dryrun) {
    print "Saved Dockerfile as: $dockerfile\n";
} else {
    system('docker', 'build', '-t', $tag, '-f', $dockerfile, $context) and
        die "The call to 'docker build ...' failed";
    unlink($dockerfile) or die "Could not remove $dockerfile";
}

rmtree($context) or die "Could not remove $context";

# --------------------------------------------------------------------------
# Helper functions for building Dockerfiles
# --------------------------------------------------------------------------

# Usage: reginaVersionCmp('6.0.1', '7.3')
#
# Returns -1, 0 or 1 according to whether LHS </=/> RHS chronologically.
# Each argument is either a regina version string, or 'current' (which means
# the latest development code, i.e., the current git master).
#
sub reginaVersionCmp {
    my $lhs = shift;
    my $rhs = shift;
    (defined $lhs and defined $rhs) or die;
    $lhs eq 'current' and return ($rhs eq 'current' ? 0 : 1);
    $rhs eq 'current' and return -1;
    return cmp_version($lhs, $rhs);
}

# Usage: reginaVersionInRange('7.0', '6.0.1', '7.3')
#
# Returns a boolean: reginaVersionInRange(test, lower, upper) returns true
# iff test is in the range [lower, upper], including the endpoints.
#
# Each argument is either a regina version string, or 'current' (which means
# the latest development code, i.e., the current git master).  Versions are
# compared chronologically, using reginaVersionCmp().
#
sub reginaVersionInRange {
    my $test = shift;
    my $lower = shift;
    my $upper = shift;
    (defined $test and defined $lower and defined $upper) or die;
    reginaVersionCmp($lower, $upper) <= 0 or die;
    return (reginaVersionCmp($test, $lower) >= 0 and
        reginaVersionCmp($test, $upper) <= 0);
}

# Usage: reginaVersionInRangeStrict('7.0', '6.0.1', '7.3')
#
# Returns a boolean: reginaVersionInRangeStrict(test, lower, upper) returns true
# iff test is in the range (lower, upper), excluding the endpoints.
#
# Each argument is either a regina version string, or 'current' (which means
# the latest development code, i.e., the current git master).  Versions are
# compared chronologically, using reginaVersionCmp().
#
sub reginaVersionInRangeStrict {
    my $test = shift;
    my $lower = shift;
    my $upper = shift;
    (defined $test and defined $lower and defined $upper) or die;
    reginaVersionCmp($lower, $upper) < 0 or die;
    return (reginaVersionCmp($test, $lower) > 0 and
        reginaVersionCmp($test, $upper) < 0);
}
# Usage: debianCmp('buster')
#
# Returns -1, 0 or 1 according to whether the VM's debian version is </=/> RHS.
# The argument should be a debian codename.
#
sub debianCmp {
    $dist eq 'debian' or die;
    my $arg = shift;
    my $lhs = $debianVersion{$release};
    my $rhs = $debianVersion{$arg};
    defined $lhs or die "Unrecognised debian release: $release";
    defined $rhs or die "Unrecognised debian release: $$arg";
    return ($lhs < $rhs ? -1 : $lhs > $rhs ? 1 : 0);
}

# Usage: ubuntuCmp('bionic')
#
# Returns -1, 0 or 1 according to whether the VM's ubuntu version is </=/> RHS.
# The arguments should be an ubuntu codename.
#
sub ubuntuCmp {
    $dist eq 'ubuntu' or die;
    my $arg = shift;
    my $lhs = $ubuntuVersion{$release};
    my $rhs = $ubuntuVersion{$arg};
    defined $lhs or die "Unrecognised ubuntu release: $release";
    defined $rhs or die "Unrecognised ubuntu release: $$arg";
    return cmp_version($lhs, $rhs);
}

# Usage: debianUbuntuCmp('stretch', 'focal')
#
# Equivalent to calling debianCmp(first arg) or ubuntuCmp(second arg)
# according to whether the VM is using debian or ubuntu respectively.
#
sub debianUbuntuCmp {
    my $arg = shift;
    $dist eq 'debian' and return debianCmp($arg);
    $arg = shift;
    $dist eq 'ubuntu' and return ubuntuCmp($arg);
    die;
}

# Usage: debStyle()
#
# Returns true iff we are building an image for debian or ubuntu.
#
sub debStyle {
    return ($dist eq 'debian' or $dist eq 'ubuntu');
}

# Usage: rpmStyle()
#
# Returns true iff we are building an image for fedora or opensuse.
#
sub rpmStyle {
    return ($dist eq 'fedora' or $dist eq 'opensuse');
}

# Usage: from('basic')
#
# Initialises the Dockerfile as starting from the given image type.
# For rolling releases, an argument of 'bare' will be automatically
# converted to 'rolling'.
#
sub from {
    my $fromType = shift;
    if ($fromType eq 'bare' && ($dist eq 'arch' or $release eq 'sid')) {
        $fromType = 'rolling';
    }
    my $fromVersion = ($dist eq 'arch' ? $dist : "$dist:$relarch");
    return "FROM $fromType/$fromVersion\n";
}

# Usage: aptUpdate()
#
# Returns a shell command that updates the package listings on a debian/ubuntu
# system.  In most cases this is just 'apt-get update'; however, on ancient
# debian systems that did not use secure APT by default, it also includes a
# call to apt-check-sigs.
#
sub aptUpdate() {
    my $cmd = 'apt-get update';
    $dist eq 'debian' and debianCmp('sarge') <= 0 and $cmd .= ' && /usr/local/bin/apt-check-sigs';
    return $cmd;
}

# Usage: addUniverse()
#
# Adds universe to the APT sources on ubuntu, does nothing otherwise.
#
sub addUniverse {
    $dist eq 'ubuntu' and return "RUN sed -i -s 's/ main\$/ main universe/' /etc/apt/sources.list; cat /etc/apt/sources.list\n";
    return '';
}

# Usage: addMultiverse()
#
# Adds both universe and multiverse to the APT sources on ubuntu, does nothing
# otherwise.
#
sub addMultiverse {
    addUniverse();
    $dist eq 'ubuntu' and return "RUN sed -i -s 's/ universe\$/ universe multiverse/' /etc/apt/sources.list; cat /etc/apt/sources.list\n";
    return '';
}

# Usage: addNonUS()
#
# Adds non-US to the APT sources on ancient debian releases that needed it for
# crypto-related packages, does nothing otherwise.
#
sub addNonUS {
    $dist eq 'debian' and debianCmp('sarge') < 0 and return "RUN echo 'deb http://archive.debian.org/debian-non-US $release/non-US main' >> /etc/apt/sources.list; cat /etc/apt/sources.list\n";
    return '';
}

# Usage: addJava()
#
# Adds the ancient Blackdown java-linux repositories on debian/ubuntu, does
# nothing otherwise.
#
sub addJava {
    debStyle() or return undef;

    my $ans = '';
    my $sections = (debianUbuntuCmp('sarge', 'breezy') >= 0 ? 'non-free' : 'main non-free');
    if ($dist eq 'debian') {
        # Use our own private mirror of the blackdown repository.
        # We import both Ben's old and new keys, since sarge struggles with
        # the old key (possibly due to the SHA256 digest algorithm?) and
        # woody struggles with the new key (it cannot read the self-signature).
        $ans .= addRepo("deb http://lab.benburton.org/archive/java/ $release $sections", 'regina-all-keys.asc');
    } else {
        ubuntuCmp('hardy') < 0 or die 'Blackdown java on ubuntu was removed in hardy';
        $ans .= addMultiverse();
    }

    # Pre-seed answers to some invasive question that are otherwise asked
    # during installation, since with docker build we cannot interact with the
    # installation process.
    if ($dist eq 'debian' and debianCmp('woody') <= 0) {
        # TODO: Work out what to do here, since woody does not have
        # debconf-set-selections (at least, not by default).
    } else {
        $ans .= copyAndRunCommand('debconf-set-selections /root/java.conf', 'java.conf');
    }

    return $ans;
}

# Usage: refreshAndInstall('zsh gcc ...')
#
# Refreshes the package list and installs the given list of packages.
#
# There is an optional second boolean argument which, if true, will perform
# a "slim" installation that excludes recommended/suggested packages (if the
# distribution supports it).
#
sub refreshAndInstall {
    # Side note: the dnf option install_weak_deps=False only seems to have
    # appeared in fedora 23.  For fedora 22 we get a warning that is loud
    # but harmless, and so we don't worry about disabling it here.
    my $pkgs = shift;
    my $slim = shift;
    my $slimopt = '';
    if ($slim) {
        $dist eq 'debian' and debianCmp('etch') > 0 and $slimopt = '--no-install-recommends ';
        $dist eq 'ubuntu' and ubuntuCmp('dapper') > 0 and $slimopt = '--no-install-recommends ';
        $dist eq 'fedora' and $slimopt = '--setopt=install_weak_deps=False ';
        $dist eq 'opensuse' and $slimopt = '--no-recommends ';
    }
    ($dist eq 'debian' or $dist eq 'ubuntu') and return 'RUN ' . aptUpdate() . " && apt-get install -y $slimopt$pkgs\n";
    $dist eq 'fedora' and return "RUN dnf install -y -b --refresh $slimopt$pkgs\n";
    $dist eq 'opensuse' and return "RUN zypper refresh && zypper install -y $slimopt$pkgs\n";
    $dist eq 'arch' and return "RUN pacman --noconfirm --noprogressbar -Syy && pacman --noconfirm --noprogressbar -S $slimopt$pkgs\n";
    die;
}

# Usage: upgradeAndInstall('zsh gcc ...')
#
# Refreshes the package list, upgrades all currently installed packages, and
# then installs the given list of packages.
#
# There is an optional second boolean argument which, if true, will perform
# a "slim" installation that excludes recommended/suggested packages (if the
# distribution supports it).
#
sub upgradeAndInstall {
    my $pkgs = shift;
    my $slim = shift;
    my $slimopt = '';
    if ($slim) {
        $dist eq 'debian' and debianCmp('etch') > 0 and $slimopt = '--no-install-recommends ';
        $dist eq 'ubuntu' and ubuntuCmp('dapper') > 0 and $slimopt = '--no-install-recommends ';
        $dist eq 'fedora' and $slimopt = '--setopt=install_weak_deps=False ';
        $dist eq 'opensuse' and $slimopt = '--no-recommends ';
    }
    ($dist eq 'debian' or $dist eq 'ubuntu') and return 'RUN ' . aptUpdate() . " && apt-get dist-upgrade -y && apt-get install -y $slimopt$pkgs\n";
    $dist eq 'fedora' and return "RUN dnf upgrade -y -b --refresh $slimopt&& dnf install -y -b $slimopt$pkgs\n";
    $dist eq 'opensuse' and return "RUN zypper refresh && zypper update -y && zypper install -y $slimopt$pkgs\n";
    $dist eq 'arch' and return "RUN pacman --noconfirm --noprogressbar -Syy && pacman --noconfirm --noprogressbar -Syu && pacman --noconfirm --noprogressbar -S $slimopt$pkgs\n";
    die;
}

# Usage: addUser('username')
#
# Adds a new ordinary user with the given username.
#
sub addUser {
    my $username = shift;
    if (debStyle() and debianUbuntuCmp('etch', 'hardy') <= 0) {
        return "RUN groupadd $username && useradd -s /bin/bash -m $username -g $username\n";
    } else {
        return "RUN useradd -U -s /bin/bash -m $username\n";
    }
}

# Usage: copyAndRunCommand('command', 'file1', ...)
#
# Copies all files given in the second and later arguments from this directory
# into the VM, then runs the given command in the shell within the VM, and then
# deletes the copied files from the VM.
#
sub copyAndRunCommand {
    my $command = shift;

    my @toAdd = ();
    while (my $arg = shift) {
        -e $arg or die "Missing supporting file: $arg";
        copy($arg, "$context/$arg") or die;
        push @toAdd, $arg;
    }

    my $ans = '';
    $ans .= "ADD $_ /root/$_\n" foreach (@toAdd);
    $ans .= "RUN $command && rm";
    $ans .= " /root/$_" foreach (@toAdd);
    $ans .= "\n";
    return $ans;
}

# Usage: copyAndRun('script', 'perl')
#
# Copies the given script from this directory into the VM, runs it in the VM,
# and then deletes from the VM.
#
# The second argument, if present, is the interpreter to use to run the script.
# If absent, the script is assumed to be executable and will be run directly.
#
# There may be additional arguments (third and beyond), representing other
# supporting files in this directory.  These will also be copied into the VM
# before the script is run, and deleted from the VM after the script is run.
#
sub copyAndRun {
    my $script = shift;
    my $interpreter = shift;

    -e $script or die;
    copy($script, "$context/$script") or die;
    my @toAdd = ($script);

    while (my $arg = shift) {
        -e $arg or die "Missing supporting file: $arg";
        copy($arg, "$context/$arg") or die;
        push @toAdd, $arg;
    }

    my $ans = '';
    $ans .= "ADD $_ /root/$_\n" foreach (@toAdd);
    $ans .= ($interpreter ? "RUN $interpreter " : 'RUN ');
    $ans .= "/root/$script && rm";
    $ans .= " /root/$_" foreach (@toAdd);
    $ans .= "\n";
    return $ans;
}

# Usage: addRepo('https://.../foo.repo')
#
# Adds the given repository to the package management system.
# The repository should either be an URL (for RPM-based distributions), or an
# apt-line (for debian and ubuntu).  Arch and fedora are not (yet) supported.
#
# For debian and ubuntu, a second optional argument is supported: the name
# of a file in this directory containing signing keys for the repository.
# These will be added to the list of trusted keys (typically via apt-key).
#
# The package listings will _not_ be refreshed.
#
sub addRepo {
    my $repo = shift;
    my $keyfile = shift;
    my $ans = '';
    if (debStyle()) {
        if (defined $keyfile) {
            if ($dist eq 'debian' and debianCmp('sarge') <= 0) {
                # This debian release was before secure APT became the default.
                # Add the key to trustedkeys.gpg, which is what apt-check-sigs
                # (the manual secure APT checker) uses for verification.
                #
                # Side note: is there a good way to import a key directly
                # into trustedkeys.gpg instead of going via public.gpg?
                # (The approach below is convoluted but harmless, since
                # we never use /root/.gnupg/public.gpg in these images.)
                $ans .= copyAndRunCommand("mv /root/.gnupg/trustedkeys.gpg /root/.gnupg/pubring.gpg && gpg --import < /root/$keyfile || true", $keyfile);
                $ans .= "RUN mv /root/.gnupg/pubring.gpg /root/.gnupg/trustedkeys.gpg\n";
            } else {
                $ans .= copyAndRunCommand("apt-key add /root/$keyfile", $keyfile);
            }
        }

        my $slimopt = (debianUbuntuCmp('etch', 'dapper') > 0 ? '--no-install-recommends ' : '');
        if ($dist eq 'debian' and debianCmp('sarge') <= 0) {
            $ans .= "RUN echo '$repo' >> /etc/apt/sources.list && cat /etc/apt/sources.list\n";
        } else {
            $hasAddedRepo or $ans = "RUN apt-get install -y ${slimopt}software-properties-common\n";
            $ans .= "RUN apt-add-repository -y '$repo' && cat /etc/apt/sources.list\n";
        }
    } elsif ($dist eq 'opensuse') {
        defined $keyfile and die;
        $ans .= "RUN zypper addrepo '$repo' && zypper repos\n";
    } else {
        die;
    }
    $hasAddedRepo = 1;
    return $ans;
}

# Usage: removeRepo('deb https://...')
#
# Removes the given repository from the given package management system.
# The same repository _must_ have been added earlier by addRepo().
# Currently this is only supported for debian and ubuntu.
#
# The package listings will _not_ be refreshed.
#
sub removeRepo {
    my $repo = shift;
    if (debStyle()) {
        return "RUN apt-add-repository -yr '$repo' && cat /etc/apt/sources.list\n";
    } else {
        die;
    }
}

# Usage: cleanup()
#
# Clears the package manager cache.
#
sub cleanup {
    ($dist eq 'debian' or $dist eq 'ubuntu') and return "RUN apt-get clean\n";
    $dist eq 'fedora' and return "RUN dnf clean all\n";
    $dist eq 'opensuse' and return "RUN zypper clean\n";
    $dist eq 'arch' and return "RUN yes | pacman --noprogressbar -Scc\n";
    die;
}

# --------------------------------------------------------------------------
# Basic user image
# --------------------------------------------------------------------------

sub basic {
    print("Basic user image for $dist $release\n");

    my $bare = ($dist eq 'arch' || $release eq 'sid' ? 'rolling' : 'bare');
    my $pkgs = 'ca-certificates zsh wget';
    $dist eq 'debian' and debianCmp('etch') > 0 and $pkgs .= ' apt-transport-https';
    $pkgs .= ($dist eq 'fedora' ? ' gnupg2' : $dist eq 'opensuse' ? ' gpg2' :
        ' gnupg');
    debStyle() or $pkgs .= ' which perl';
    $pkgs .= ($dist eq 'fedora' ? ' vim-enhanced' : ' vim');

    my $data = from('bare');

    if ($dist eq 'debian' and debianCmp('sarge') <= 0) {
        # This debian release was before secure APT was the default.
        # Set things up so that we can use apt-check-sigs ourselves.

        # GnuPG needs a first run just to initialise itself.
        # Both GnuPG runs (the initialisation and the subsequent key import)
        # may return a non-zero exit status, and this is okay.
        $data .= "RUN gpg < /dev/null || true\n";
        $data .= copyAndRunCommand("gpg --import /root/$release-keys.asc || true", "$release-keys.asc");
        $data .= "RUN mv /root/.gnupg/pubring.gpg /root/.gnupg/trustedkeys.gpg\n";
        $data .= copyAndRunCommand('cp /root/apt-check-sigs /usr/local/bin && chmod a+x /usr/local/bin/apt-check-sigs', 'apt-check-sigs');
    }

    $data .= addNonUS();
    # On the earliest ubuntus, ca-certificates was part of universe, not main.
    $dist eq 'ubuntu' and ubuntuCmp('breezy') <= 0 and $data .= addUniverse();
    $data .= upgradeAndInstall($pkgs);
    $data .= cleanup();
    $data .= addUser('user');

    # For newer openSUSE packages, as we bring in more and more packages
    # (especially GUI/desktop packages), we start to see things being signed
    # with the openSUSE backports keys.  Might as well add these keys now.
    $dist eq 'opensuse' and $data .= copyAndRunCommand('rpmkeys --import /root/opensuse-backports.key', 'opensuse-backports.key');

    # For older distributions we need new root certificates just to download
    # packages from our own repositories.  For fedora, we fix this now.
    # For the oldest debian/ubuntu distributions we have a similar problem,
    # but we do not try to install newer certificates because we then just
    # run into different problems involving a too-old libssl.  Instead we just
    # put our own repositories under http://..., not https://... .
    $dist eq 'fedora' and $release <= 24 and $data .= copyAndRun('certificates-fedora.sh', 'bash');

    return $data;
}

# --------------------------------------------------------------------------
# Full desktop image
# --------------------------------------------------------------------------

sub desktop {
    print("Full desktop image for $dist $release\n");

    # For now, we do not support desktop images on openSUSE.
    # They are problematic because: (i) they are *enormous*; (ii) the package
    # installation includes long waits whilst trying to connect to services
    # that are not running since we are in a VM; and (iii) there are many
    # NOKEY errors because many of the packages used are signed with the
    # openSUSE backports key (8A49EB0325DB7AE0).
    #
    # Regarding (i): we could slim things down by only installing
    # patterns-kde-kde_plasma, but this seems to eject too much.  Not sure
    # what the sensible compromise is (or if openSUSE even offers one).
    # Regarding (iii): we could just trust the backports signing key, but I'm
    # not convinced it's a good idea to accept backports in general for these
    # docker images - openSUSE has a history of package updates messing up
    # build environments, and this is not something I want to babysit.
    #
    $dist eq 'opensuse' and return undef;

    my $data = from('basic');
    if ($dist eq 'debian') {
        $data .= upgradeAndInstall('task-gnome-desktop');
    } elsif ($dist eq 'ubuntu') {
        $data .= upgradeAndInstall('ubuntu-desktop');
    } elsif ($dist eq 'fedora') {
        $data .= "RUN dnf upgrade -y -b --refresh && dnf group install -y -b GNOME\n";
    } elsif ($dist eq 'opensuse') {
        $data .= upgradeAndInstall('patterns-kde-kde');
    } elsif ($dist eq 'arch') {
        $data .= upgradeAndInstall('gnome');
    } else {
        die;
    }
    $data .= cleanup();
    return $data;
}

# --------------------------------------------------------------------------
# General development machine
# --------------------------------------------------------------------------

sub pkgdev {
    print("Package development for $dist $release\n");

    my $purpose = shift;
    if (defined $purpose) {
        print("Tailed for building $purpose\n");

        my $data = from('pkgdev');
        my $pkgs;

        if ($purpose eq 'doxygen') {
            $dist eq 'opensuse' or
                die 'pkgdev-doxygen only supported for opensuse';
            $data .= refreshAndInstall('bison cmake flex', 1);
        } elsif ($purpose eq 'tokyocabinet') {
            $dist eq 'opensuse' or
                die 'pkgdev-tokyocabinet only supported for opensuse';
            $data .= refreshAndInstall('autoconf automake libbz2-devel libltdl7 libtool m4 site-config zlib-devel', 1);
        } elsif ($purpose eq 'btools') {
            debStyle() or die 'pkgdev-btools only supported for debian/ubuntu';
            # Note: I have not actually looked at pre-breezy ubuntus to see
            # what is available (if anything).
            my $sdk = (debianUbuntuCmp('sarge', 'breezy') >= 0 ? 'j2sdk1.4' : 'j2sdk1.3');
            $data .= addJava();
            $data .= refreshAndInstall($sdk);
        } else {
            die 'Unknown pkgdev-* type';
        }

        $data .= cleanup();
        return $data;
    }

    my $pkgs = 'gdb';
    if ($dist eq 'debian') {
        if (debianCmp('lenny') > 0) {
            $pkgs .= ' git';
        } elsif (debianCmp('etch') >= 0) {
            # For etch and lenny, git referred to something different
            # (GNU Interactive Tools).
            $pkgs .= ' git-core';
        }
        # Debian sarge and earlier do not appear to have git at all.
    } elsif ($dist eq 'ubuntu') {
        if (ubuntuCmp('lucid') > 0) {
            $pkgs .= ' git';
        } elsif (ubuntuCmp('dapper') >= 0) {
            # For dapper..lucid, git referred to something different
            # (GNU Interactive Tools).
            $pkgs .= ' git-core';
        }
        # Ubuntu breezy and earlier do not appear to have git at all.
    } else {
        $pkgs .= ' git';
    }
    debStyle() and $pkgs .= ' build-essential devscripts fakeroot lintian debhelper';
    debStyle() and debianUbuntuCmp('sarge', 'breezy') > 0 and $pkgs .= ' autopkgtest';
    rpmStyle() and $pkgs .= ' rpm-build gcc gcc-c++';
    $dist eq 'arch' and $pkgs .= ' base-devel devtools namcap';
    $dist eq 'opensuse' and $pkgs .= ' appstream-glib';
    $dist eq 'fedora' and $pkgs .= ' libappstream-glib-builder make';
    $dist eq 'fedora' and $release >= 26 and $pkgs .= ' dnf-utils';

    # Add additional non-default compilers:
    # - For debian and LTS ubuntu releases, include all available versions of
    #   gcc and clang, so we can test different compiler versions as necessary.
    # - For openSUSE, add a modern compiler because the defaults are _ancient_.
    if ($dist eq 'debian') {
        my @gcc = ();
        $release eq 'woody' and @gcc = qw(2.95 3.0);
        $release eq 'sarge' and @gcc = qw(2.95 3.3 3.4);
        $release eq 'etch' and @gcc = qw(2.95 3.3 3.4 4.1);
        $release eq 'lenny' and @gcc = qw(4.1 4.2 4.3);
        $release eq 'squeeze' and @gcc = qw(4.3 4.4);
        $release eq 'wheezy' and @gcc = qw(4.4 4.6 4.7);
        $release eq 'jessie' and @gcc = qw(4.8 4.9);
        $release eq 'stretch' and @gcc = qw(6);
        $release eq 'buster' and @gcc = qw(7 8);
        $release eq 'bullseye' and @gcc = qw(9 10);
        $release eq 'bookworm' and @gcc = qw(11 12);
        $pkgs .= " gcc-$_ g++-$_" foreach @gcc;

        my @clang = ();
        $release eq 'jessie' and @clang = qw(3.4 3.5);
        $release eq 'stretch' and @clang = qw(3.8 3.9 4.0 7);
        $release eq 'buster' and @clang = qw(6.0 7 11 13);
        $release eq 'bullseye' and @clang = qw(9 11 13);
        $release eq 'bookworm' and @clang = qw(13 14 15);
        $pkgs .= " clang-$_" foreach @clang;
        # These releases just had a "clang" package, without versions.
        ($release eq 'squeeze' or $release eq 'wheezy') and $pkgs .= ' clang';
    } elsif ($dist eq 'ubuntu') {
        # Note: the non-standard compiler versions require universe.
        #
        # Moreover, on arm64 (where trusty is the oldest ubuntu LTS we get),
        # the trusty port does not actually _have_ these extra compilers.
        # (I should check, maybe that port did not include universe at all?)
        my @gcc = ();
        $release eq 'dapper' and @gcc = qw(2.95 3.3 3.4 4.0);
        $release eq 'hardy' and @gcc = qw(3.3 3.4 4.1 4.2);
        $release eq 'lucid' and @gcc = qw(4.1 4.3 4.4);
        $release eq 'precise' and @gcc = qw(4.4 4.5 4.6);
        $release eq 'trusty' and $usearch ne 'aarch64' and
            @gcc = qw(4.4 4.6 4.7 4.8);
        $release eq 'xenial' and @gcc = qw(4.7 4.8 4.9 5);
        $release eq 'bionic' and @gcc = qw(4.8 5 6 7 8);
        $release eq 'focal' and @gcc = qw(7 8 9 10);
        $release eq 'jammy' and @gcc = qw(9 10 11 12);
        $pkgs .= " gcc-$_ g++-$_" foreach @gcc;

        my @clang = ();
        $release eq 'precise' and @clang = qw(3.4);
        # On trusty, the different clang versions conflict with one another.
        # We have to choose just one - we go with 3.3 because it's the one
        # clang version that we can't get elsewhere.
        # $release eq 'trusty' and @clang = qw(3.3 3.4 3.5 3.6 3.8 3.9);
        $release eq 'trusty' and $usearch ne 'aarch64' and @clang = qw(3.3);
        $release eq 'xenial' and @clang = qw(3.5 3.6 3.7 3.8 3.9 4.0 8);
        $release eq 'bionic' and @clang = qw(3.9 4.0 5.0 6.0 8 9 10);
        $release eq 'focal' and @clang = qw(6.0 7 8 9 10 12);
        $release eq 'jammy' and @clang = qw(11 12 13 14 15);
        $pkgs .= " clang-$_" foreach @clang;
        # These LTS releases just had a "clang" package, without versions.
        $release eq 'lucid' and $pkgs .= ' clang';
    } elsif ($dist eq 'opensuse') {
        my $latest;
        $release eq '42.3' and $latest = '7';  # default: gcc48
        # 15.0 only ships gcc7
        $release eq '15.1' and $latest = '8';  # default: gcc7
        $release eq '15.2' and $latest = '9';  # default: gcc7
        $release eq '15.3' and $latest = '10'; # default: gcc7
        $release eq '15.4' and $latest = '11'; # default: gcc7
        $release eq '15.5' and $latest = '12'; # default: gcc7
        $latest and $pkgs .= " gcc$latest gcc$latest-c++";
    }

    # We should include hexdump.  On recent debian systems this comes through
    # bsdextrautils, which is recommended by the required package bsdutils,
    # and which seems to be installed already on our pkgdev images (though
    # I am not sure of the particular dependency route).

    my $data = from('basic');
    $data .= addUniverse(); # for non-default compilers on ubuntu

    # Add source repositories for those distros that don't have them already.
    debStyle() and $data .= copyAndRun('deb-src.pl', 'perl');
    $dist eq 'opensuse' and $data .= "RUN zypper addrepo http://download.opensuse.org/source/distribution/leap/$release/repo/oss/ source\n";

    $data .= upgradeAndInstall($pkgs, 1);
    $data .= cleanup();
    if ($release eq '37') {
        # On Fedora 37, appstream-builder (via gdk-pixbuf) cannot recognise
        # any icon formats at all.  The following line seems to fix this.
        $data .= "RUN /usr/bin/update-mime-database /usr/share/mime\n";
    }
    $data .= addUser('build');
    rpmStyle() and $data .= "RUN mkdir /home/build/rpmbuild && mkdir /home/build/rpmbuild/{SOURCES,SPECS} && chown -R build:build /home/build/rpmbuild\n";
    return $data;
}

# --------------------------------------------------------------------------
# Building Regina
# --------------------------------------------------------------------------

sub regina {
    print("Regina development for $dist $release\n");

    my $regver = shift;
    if ($regver) {
        print("Tailored for Regina $regver\n");
    } else {
        print("Tailored for current Regina development\n");
        $regver = 'current';
    }

    # Additional tools/libraries that regina used at different points in time:
    my $needBoostHeadersOnly = reginaVersionInRangeStrict($regver, '5.1', '7.0');
    my $needBoostLibs = reginaVersionInRange($regver, '3.95', '5.1');
    my $needCmake = (reginaVersionCmp($regver, '4.90') >= 0);
    my $needCORBA = reginaVersionInRange($regver, '2.3', '2.4');
    my $needCppUnit = reginaVersionInRange($regver, '3.97', '7.3');
    my $needDocbookUtils = (reginaVersionCmp($regver, '4.0') <= 0);
    my $needFastJar = reginaVersionInRange($regver, '3.1', '3.2');
    my $needGraphvizLibs = (reginaVersionCmp($regver, '5.0') >= 0);
    my $needGraphvizRuntime = (reginaVersionCmp($regver, '3.2') <= 0);
    my $needJade = (reginaVersionCmp($regver, '3.2') <= 0);
    my $needJansson = reginaVersionInRange($regver, '5.1', '7.3');
    my $needJava = (reginaVersionCmp($regver, '3.2') <= 0);
    my $needKDE = reginaVersionInRange($regver, '3.95', '4.90');
    my $needKVStore = (reginaVersionCmp($regver, '4.96') >= 0);
    my $needMPI = reginaVersionInRange($regver, '4.2', '5.1');
    my $needPopt = reginaVersionInRange($regver, '3.1', '7.3');
    my $needPython = (reginaVersionCmp($regver, '3.95') >= 0);
    my $needQt = (reginaVersionCmp($regver, '4.92') >= 0);
    my $needSharedMimeInfo = (reginaVersionCmp($regver, '4.90') >= 0);
    my $needSourceHighlight = reginaVersionInRange($regver, '4.92', '5.0');
    my $needXML = (reginaVersionCmp($regver, '3.0') >= 0);
    my $needXSLT = (reginaVersionCmp($regver, '4.92') >= 0);

    # The highest Qt major version that this version of Regina supports:
    my $maxQt = (reginaVersionCmp($regver, '7.1') >= 0 ? 6 :
        reginaVersionCmp($regver, '5.0') >= 0 ? 5 :
        $needQt ? 4 : undef);

    # The highest Python major version that this version of Regina supports:
    my $maxPython = (reginaVersionCmp($regver, '5.1') > 0 ? 3 :
        $needPython ? 2 : undef);

    # The specific KDE version that this version of Regina supports:
    my $useKDE = ($regver eq '4.90' ? 4 :
        $needKDE ? 3 : undef);

    # Note: we use curl to download source tarballs.
    my $pkgs = 'curl doxygen';
    $needGraphvizRuntime and $pkgs .= ' graphviz';
    $needJade and $pkgs .= ' jade';
    $needCmake and $pkgs .= ' cmake';
    $needSharedMimeInfo and $pkgs .= ' shared-mime-info';
    $needDocbookUtils and $pkgs .= ' docbook-utils';
    $needFastJar and $pkgs .= ' fastjar';
    if (debStyle()) {
        # There was a period where debian/rules reran the autotools scripts.
        # Possibly this was due to the patches to admin/kde.m4.ext, though
        # these patches only appeared in the packaging for regina 4.3.1.
        # The autotools dependencies remained however until regina switched
        # to cmake.
        reginaVersionInRange($regver, '4.3.1', '4.6') and
            (debianUbuntuCmp('etch', 'breezy') >= 0) and
            $pkgs .= ' automake1.9';

        $pkgs .= (debianUbuntuCmp('wheezy', 'oneiric') < 0 ? ' libgmp3-dev' : ' libgmp-dev');
        $needXML and $pkgs .= ' libxml2-dev zlib1g-dev';
        $needXSLT and $pkgs .= ' xsltproc';
        $needKVStore and $pkgs .= ' libtokyocabinet-dev pkg-config';
        # For the cppunit package name, the threshold of hoary below might need
        # to be earlier; this has not been tested.  This is also harmless,
        # since breezy still had a transitional cppunit package.
        $needCppUnit and $pkgs .= (debianUbuntuCmp('woody', 'hoary') > 0 ? ' libcppunit-dev' : ' cppunit');
        $needGraphvizLibs and $pkgs .= ' libgraphviz-dev';
        $needJansson and $pkgs .= ' libjansson-dev';
        $needPopt and $pkgs .= ' libpopt-dev';
        $needSourceHighlight and $pkgs .= ' libsource-highlight-dev';
        $needCORBA and $pkgs .= ' omniorb-dev';
        $needMPI and $pkgs .= (reginaVersionCmp($regver, '4.90') >= 0 ? ' mpi-default-dev' : ' libmpich1.0-dev');
        $needBoostHeadersOnly and $pkgs .= ' libboost-dev';
        if ($needBoostLibs) {
            $pkgs .= ' libboost-python-dev';
            reginaVersionInRange($regver, '5.0', '5.1') and $pkgs .= ' libboost-iostreams-dev';
            reginaVersionInRange($regver, '4.92', '5.0') and $pkgs .= ' libboost-regex-dev';
        }
        if ($needPython) {
            if (debianUbuntuCmp('wheezy', 'saucy') > 0) {
                $pkgs .= ' dh-python';
            } elsif (debianUbuntuCmp('lenny', 'intrepid') >= 0) {
                $pkgs .= ' python-support';
            } else {
                # No special python support packages were required here.
                # Instead we used XS-Python-Version and XB-Python-Version
                # in debian/control.
            }
            if ($maxPython == 2) {
                $pkgs .= ' python-dev';
            } elsif (reginaVersionCmp($regver, '7.1') < 0 and debianUbuntuCmp('buster', 'eoan') <= 0) {
                # Although debian buster supported python3, we always built regina
                # on buster using python2.  Likewise for ubuntu disco.  As for
                # eoan, this only ever saw regina 5.1, which used python2 because
                # regina 5.1 did not support python3.  Hence the debian/ubuntu
                # thresholds above.  This is only relevant for regina <= 7.0;
                # after this, python2 support was dropped completely from regina.
                $pkgs .= ' python-dev';
            } else {
                $pkgs .= ' python3-dev';
            }
        }
        if ($needQt) {
            if ($maxQt <= 4 or ($dist eq 'ubuntu' and ubuntuCmp('quantal') <= 0)) {
                $pkgs .= ' libqt4-dev';
            } elsif ($maxQt <= 5 or debianUbuntuCmp('bullseye', 'impish') <= 0) {
                $pkgs .= ' qtbase5-dev libqt5svg5-dev';
            } else {
                $pkgs .= ' qt6-base-dev libqt6svg6-dev';
            }
            # This works around an issue that was specific to ubuntu jammy:
            $release eq 'jammy' and $pkgs .= ' libgl-dev';
        } elsif ($needKDE) {
            # Note: kdelibs5 was from KDE4, and kdelibs4 was from KDE3.
            $pkgs .= ($useKDE == 4 ? ' kdelibs5-dev pkg-kde-tools' : ' kdelibs4-dev');
        } elsif ($needJava) {
            # TODO: jython libbtools-java j2sdk1.x
        }
    } elsif ($dist eq 'fedora') {
        $pkgs .= ' gmp-devel';
        ($needQt or ($needKDE and $useKDE == 4)) and $pkgs .= ' desktop-file-utils';
        $needXML and $pkgs .= ' libxml2-devel zlib-devel';
        $needXSLT and $pkgs .= ' libxslt';
        $needKVStore and $pkgs .= ' tokyocabinet-devel pkgconfig';
        $needCppUnit and $pkgs .= ' cppunit-devel';
        $needGraphvizLibs and $pkgs .= ' graphviz-devel';
        $needJansson and $pkgs .= ' jansson-devel';
        $needPopt and $pkgs .= ($release > 7 ? ' popt-devel' : ' popt');
        $needSourceHighlight and $pkgs .= ' source-highlight-devel';
        $needCORBA and die 'CORBA not supported for fedora packaging';
        # MPI was excluded from the fedora builds from regina 4.4 onwards.
        $needMPI and reginaVersionCmp($regver, '4.4') < 0 and $pkgs .= ($release > 5 ? ' lam-devel' : ' lam');
        ($needBoostHeadersOnly or $needBoostLibs) and $pkgs .= ' boost-devel';
        if ($needPython) {
            if ($maxPython == 2) {
                $pkgs .= ($release <= 25 ? ' python-devel' : ' python2-devel');
                $needBoostLibs and $release >= 29 and $pkgs .= ' boost-python2-devel';
            } else {
                $pkgs .= ' python3-devel';
                $needBoostLibs and $pkgs .= ' boost-python3-devel';
            }
        }
        if ($needQt) {
            if ($maxQt <= 4) {
                $pkgs .= ' qt-devel';
            } elsif ($maxQt <= 5 or $release <= 34) {
                $pkgs .= ' qt5-qtbase-devel qt5-qtsvg-devel';
            } else {
                $pkgs .= ' qt6-qtbase-devel qt6-qtsvg-devel';
            }
        } elsif ($needKDE) {
            if ($useKDE == 4) {
                $pkgs .= ' kdelibs-devel';
            } else {
                if ($release >= 9) {
                    $pkgs .= ' kdelibs3-devel qt3-devel';
                } else {
                    $pkgs .= ' kdelibs-devel qt-devel';
                }
                # These extra libraries appeared as build-depends in regina's
                # fedora packaging; I suspect they were to support KDE3 but I
                # could be wrong.
                $pkgs .= ' libselinux-devel';
                $release <= 6 and $release >= 3 and $pkgs .= ' libaio-devel';
            }
        } elsif ($needJava) {
            die 'Java not supported for fedora packaging';
        }
    } elsif ($dist eq 'opensuse') {
        $pkgs .= ' sed gmp-devel';
        $needXML and $pkgs .= ' libxml2-devel zlib-devel';
        $needXSLT and $pkgs .= ' libxslt-tools';
        # KVStore is messy on openSUSE.  We deal with it below.
        $needCppUnit and $pkgs .= ' cppunit-devel';
        $needGraphvizLibs and $pkgs .= ' graphviz-devel';
        $needJansson and $pkgs .= ' libjansson-devel';
        $needPopt and $pkgs .= ' popt-devel';
        $needSourceHighlight and $pkgs .= ' libsource-highlight-devel';
        $needCORBA and die 'CORBA not supported for opensuse packaging';
        # MPI was never included in the RPM builds.
        if ($needBoostLibs) {
            if ($release =~ /^42\./) {
                # The default boost is too old for many versions of regina.
                $pkgs .= ' boost_1_61-devel';
                # This one development package covers all boost libraries.
            } else {
                # Each boost library has its own development package.
                $pkgs .= ($maxPython == 2 ? ' libboost_python-devel' : ' libboost_python-py3-devel');
                reginaVersionInRange($regver, '5.0', '5.1') and $pkgs .= ' libboost_iostreams-devel';
                reginaVersionInRange($regver, '4.92', '5.0') and $pkgs .= ' libboost_regex-devel';
            }
        } elsif ($needBoostHeadersOnly) {
            if ($release =~ /^42\./) {
                # The default boost is too old for many versions of regina.
                $pkgs .= ' boost_1_61-devel';
            } else {
                $pkgs .= ' boost-devel';
            }
        }
        if ($needPython) {
            if ($maxPython == 2 or $release =~ /^42\./) {
                $pkgs .= ' python2-devel';
            } else {
                $pkgs .= ' python3-devel';
            }
        }
        if ($needQt) {
            if ($maxQt <= 4) {
                $pkgs .= ' libqt4-devel';
            } elsif ($maxQt <= 5 or ($release =~ /^42\./ or $release =~ /^15\.[0-3]$/)) {
                $pkgs .= ' libqt5-qtbase-devel libqt5-qtsvg-devel';
            } else {
                $pkgs .= ' qt6-base-devel qt6-svg-devel';
            }
        } elsif ($needKDE) {
            $pkgs .= ($useKDE == 4 ? ' libkde4-devel libqt4-devel' : ' kdelibs3-devel qt3-devel');
        } elsif ($needJava) {
            die 'Java not supported for opensuse packaging';
        }
        if ($needKVStore) {
            if (reginaVersionCmp($regver, '7.0') >= 0) {
                $pkgs .= ' lmdb-devel';
            } elsif ($release =~ /^42\./) {
                $pkgs .= ' libtokyocabinet-devel libbz2-devel';
            } else {
                # The normal openSUSE 15.x repositories do not provide
                # tokyocabinet at all.  We need to fetch this from elsewhere;
                # we deal with this in a later block of code below.
                # We will however need libbz2-devel for tokyocabinet, which
                # we can get now.
                $pkgs .= ' libbz2-devel';
            }
            $pkgs .= ' pkg-config';
        }
    } elsif ($dist eq 'arch') {
        $pkgs .= ' gmp';
        $needXML and $pkgs .= ' libxml2 zlib';
        $needXSLT and $pkgs .= ' libxslt';
        # Regarding KVStore: tokyocabinet is shipped in our own arch repository.
        $needCppUnit and $pkgs .= ' cppunit';
        # Note: if $needGraphvizRuntime is true then we already have graphviz.
        ($needGraphvizLibs and not $needGraphvizRuntime) and $pkgs .= ' graphviz';
        $needJansson and $pkgs .= ' jansson';
        $needPopt and $pkgs .= ' popt';
        $needSourceHighlight and $pkgs .= ' source-highlight';
        $needCORBA and die 'CORBA not supported for arch packaging';
        # MPI was never included in the arch builds.
        ($needBoostHeadersOnly or $needBoostLibs) and $pkgs .= ' boost';
        $needPython and $pkgs .= ' python';
        if ($needQt) {
            $pkgs .= ' desktop-file-utils hicolor-icon-theme';
            if ($maxQt <= 4) {
                die 'Qt4 is no longer available on arch';
            } elsif ($maxQt <= 5) {
                $pkgs .= ' qt5-base qt5-svg';
            } else {
                $pkgs .= ' qt6-base qt6-svg';
            }
        } elsif ($needKDE) {
            die 'KDE 3/4 are no longer available on arch';
        } elsif ($needJava) {
            die 'Java not supported for arch packaging';
        }
    } else {
        return undef;
    }

    my $data = from('pkgdev');
    $data .= upgradeAndInstall($pkgs, 1);

    if ($release eq 'bionic' or $release eq 'buster') {
        # These are old debian/ubuntu releases for which newer versions of
        # regina required a newer doxygen and/or cmake (via our own backports
        # repository).  Note that these backports were specific to bionic and
        # buster, and were not provided for even older debian/ubuntu releases
        # (which were only ever used with old versions of regina where this
        # did not matter).
        #
        my $upgrade = 'doxygen';
        $needCmake and $upgrade .= ' cmake';
        print "NOTE: Adding backports for $release: $upgrade\n";

        $data .= "RUN apt-get install -y --no-install-recommends software-properties-common\n";
        my $repo = "deb https://people.debian.org/~bab/backports $release/";
        $data .= addRepo($repo, 'regina-key.asc');
        # Note: on buster we don't backport cmake, but in this case the extra
        # cmake in the command below is harmless.
        $data .= refreshAndInstall($upgrade);
        $data .= removeRepo($repo);
    }
    if ($dist eq 'opensuse' and $release =~ /^15\./) {
        $data .= copyAndRunCommand('rpmkeys --import /root/regina-key.asc', 'regina-key.asc');
        if (reginaVersionCmp($regver, '6.1') >= 0) {
            # So.. openSUSE 15.x ships a doxygen so ancient that we cannot use
            # it with modern Regina.  This is true even for the newest
            # openSUSE 15.x, sigh.
            #
            # In the old days we would fetch a newer doxygen from the openSUSE
            # devel:tools repository.  BUT... the devel:tools repositories seem
            # to disappear once an openSUSE release is discontinued.  Moreover,
            # there was an issue with the devel:tools repository for 15.4 where
            # the new doxygen would drag in a newer libstdc++; such things could
            # possibly cause the build machine to generate runtime dependencies
            # that are uninstallable on an out-of-the-box openSUSE installation.
            #
            # So... we cut our losses and backport a newer doxygen ourselves.
            #
            print "NOTE: Adding backported doxygen for $release\n";
            $data .= addRepo("https://people.debian.org/~bab/rpm/doxygen/opensuse/$release/doxygen.repo");
            # Note the extra argument that we sneak into zypper here.
            $data .= refreshAndInstall('--allow-vendor-change doxygen', 1);
        }

        if ($needKVStore and reginaVersionCmp($regver, '7.0') < 0) {
            # Old versions of regina needed tokyocabinet, which openSUSE 15.x
            # does not supply at all.  We need to fetch it also from our own
            # repository, which includes "forward-ports" of tokyocabinet from
            # openSUSE 42.3 to openSUSE 15.x.
            print "NOTE: Adding forward-ported tokyocabinet for $release\n";
            $data .= addRepo("https://people.debian.org/~bab/rpm/tokyocabinet/opensuse/$release/tokyocabinet.repo");
            $data .= refreshAndInstall('libtokyocabinet-devel', 1);
        }
    }

    $data .= cleanup();
    return $data;
}

# --------------------------------------------------------------------------
# Historical package archives for Regina
# --------------------------------------------------------------------------

sub archive {
    print("Archived Regina releases for $dist $release\n");

    my $data = from('basic');
    $data .= addUniverse(); # Ubuntu needs this for debian-keyring
    debStyle() and $data .= refreshAndInstall('debian-keyring', 1);

    # Set up the repository for the Regina packages.
    if (debStyle()) {
        $data .= copyAndRun('archive-deb.sh', 'bash', 'regina-key.asc');
    } elsif ($dist eq 'fedora') {
        $data .= copyAndRun('archive-fedora.sh', 'bash', 'regina-key.asc');
    } elsif ($dist eq 'opensuse') {
        $data .= copyAndRun('archive-opensuse.sh', 'bash', 'regina-key.asc');
    } else {
        # Arch is not supported for this image type.
        return undef;
    }

    $data .= upgradeAndInstall('regina-normal');
    $data .= cleanup();
    return $data;
}
