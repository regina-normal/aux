#!/usr/bin/perl -w
use File::Copy;
use File::Path;
use Version::Util qw(cmp_version);
use strict;

-e 'build' or die "This script must be run from within its own directory";

my $dryrun = 0;

my $imagetype=$ARGV[0];
my $release=$ARGV[1];
if (not ($release and $imagetype)) {
    print <<__END__;
Usage: ./build <imagetype> <release> [<arch>]

Examples:
    ./build basic 39
    ./build desktop bookworm i386
    ./build pkgdev jammy
    ./build pkgdev-doxygen 15.5
    ./build regina sid
    ./build regina-7.0 bullseye
__END__
    exit 1;
}

# Some globals for our helper functions:
my $hasAddedRepo = 0;
my %debianVersion = (
    'woody' => 3.0, 'sarge' => 3.1,
    'etch' => 4, 'lenny' => 5, 'squeeze' => 6, 'wheezy' => 7,
    'jessie' => 8, 'stretch' => 9, 'buster' => 10, 'bullseye' => 11,
    'bookworm' => 12, 'trixie' => 13, 'forky' => 14,
    'sid' => 999 );
my %ubuntuVersion = (
    'precise' => '12.04', 'quantal' => '12.10', 'raring' => '13.04',
    'saucy' => '13.10', 'trusty' => '14.04', 'utopic' => '14.10',
    'vivid' => '15.04', 'wily' => '15.10', 'xenial' => '16.04',
    'yakkety' => '16.10', 'zesty' => '17.04', 'artful' => '17.10',
    'bionic' => '18.04', 'cosmic' => '18.10', 'disco' => '19.04',
    'eoan' => '19.10', 'focal' => '20.04', 'groovy' => '20.10',
    'hirsute' => '21.04', 'impish' => '21.10', 'jammy' => '22.04',
    'kinetic' => '22.10', 'lunar' => '23.04', 'mantic' => '23.10',
    'noble' => '24.04' );

my @alldists = qw(debian ubuntu fedora opensuse arch);
my $dist;
foreach my $d (@alldists) {
    open(LIST, '<', "../supported/$d.list") or die;
    while (<LIST>) {
        chomp;
        if ($_ eq $release) {
            $dist = $d;
            last;
        }
    }
    close(LIST);
    defined $dist and last;
}
defined $dist or die "Not a release from a known distribution: $release";
print("Distribution: $dist\n");

# $arch = the architecture that was explicitly selected; may be undefined.
# $usearch = the architecture that the guest machine is using; always defined.
# TODO: Squash the possible values down to x86_64, aarch64, i386.
my $arch = $ARGV[2];
my $relarch = $release;
my $usearch = $arch;
if (defined $arch) {
    print("Architecture: $arch\n");
    $relarch .= "_$arch";
} else {
    $usearch = `uname -m`;
    chomp $usearch;
    print("Architecture: same as host ($usearch)\n");
}

my $context = "${imagetype}_${dist}_${relarch}";
-e $context and die "Stale directory needs to be removed: $context";
mkdir $context or die;

my $dockerfile = "${imagetype}_${dist}_${relarch}.Dockerfile";
my $dockerdata;
if ($imagetype eq 'basic') {
    $dockerdata = basic();
} elsif ($imagetype eq 'desktop') {
    $dockerdata = desktop();
} elsif ($imagetype eq 'pkgdev') {
    $dockerdata = pkgdev();
} elsif ($imagetype =~ /^pkgdev-([a-z0-9]+)$/) {
    $dockerdata = pkgdev($1);
} elsif ($imagetype eq 'regina') {
    $dockerdata = regina();
} elsif ($imagetype =~ /^regina-([0-9.]+)$/) {
    $dockerdata = regina($1);
} elsif ($imagetype eq 'archive') {
    $dockerdata = archive();
} else {
    die "Unknown image type: $imagetype";
}
defined $dockerdata or die "This specific docker image is not yet supported";

print("\nWriting $dockerfile...\n");
open(DOCKERFILE, '>', $dockerfile) or die;
print DOCKERFILE $dockerdata;
close(DOCKERFILE);

my $tag = ($dist eq 'arch' ? "$imagetype/$dist" : "$imagetype/$dist:$relarch");
print("Building $tag...\n\n");

if ($dryrun) {
    print "Saved Dockerfile as: $dockerfile\n";
} else {
    system('docker', 'build', '-t', $tag, '-f', $dockerfile, $context) and
        die "The call to 'docker build ...' failed";
    unlink($dockerfile) or die "Could not remove $dockerfile";
}

rmtree($context) or die "Could not remove $context";

# --------------------------------------------------------------------------
# Helper functions for building Dockerfiles
# --------------------------------------------------------------------------

# Usage: reginaVersionCmp('6.0.1', '7.3')
#
# Returns -1, 0 or 1 according to whether LHS </=/> RHS chronologically.
# Each argument is either a regina version string, or 'current' (which means
# the latest development code, i.e., the current git master).
#
sub reginaVersionCmp {
    my $lhs = shift;
    my $rhs = shift;
    (defined $lhs and defined $rhs) or die;
    $lhs eq 'current' and return ($rhs eq 'current' ? 0 : 1);
    $rhs eq 'current' and return -1;
    return cmp_version($lhs, $rhs);
}

# Usage: debianCmp('buster')
#
# Returns -1, 0 or 1 according to whether the VM's debian version is </=/> RHS.
# The argument should be a debian codename.
#
sub debianCmp {
    $dist eq 'debian' or die;
    my $arg = shift;
    my $lhs = $debianVersion{$release};
    my $rhs = $debianVersion{$arg};
    defined $lhs or die "Unrecognised debian release: $release";
    defined $rhs or die "Unrecognised debian release: $$arg";
    return ($lhs < $rhs ? -1 : $lhs > $rhs ? 1 : 0);
}

# Usage: ubuntuCmp('bionic')
#
# Returns -1, 0 or 1 according to whether the VM's ubuntu version is </=/> RHS.
# The arguments should be an ubuntu codename.
#
sub ubuntuCmp {
    $dist eq 'ubuntu' or die;
    my $arg = shift;
    my $lhs = $ubuntuVersion{$release};
    my $rhs = $ubuntuVersion{$arg};
    defined $lhs or die "Unrecognised ubuntu release: $release";
    defined $rhs or die "Unrecognised ubuntu release: $$arg";
    return cmp_version($lhs, $rhs);
}

# Usage: debianUbuntuCmp('stretch', 'focal')
#
# Equivalent to calling debianCmp(first arg) or ubuntuCmp(second arg)
# according to whether the VM is using debian or ubuntu respectively.
#
sub debianUbuntuCmp {
    my $arg = shift;
    $dist eq 'debian' and return debianCmp($arg);
    $arg = shift;
    $dist eq 'ubuntu' and return ubuntuCmp($arg);
    die;
}

# Usage: debStyle()
#
# Returns true iff we are building an image for debian or ubuntu.
#
sub debStyle {
    return ($dist eq 'debian' or $dist eq 'ubuntu');
}

# Usage: rpmStyle()
#
# Returns true iff we are building an image for fedora or opensuse.
#
sub rpmStyle {
    return ($dist eq 'fedora' or $dist eq 'opensuse');
}

# Usage: from('basic')
#
# Initialises the Dockerfile as starting from the given image type.
# For rolling releases, an argument of 'bare' will be automatically
# converted to 'rolling'.
#
sub from {
    my $fromType = shift;
    if ($fromType eq 'bare' && ($dist eq 'arch' or $release eq 'sid')) {
        $fromType = 'rolling';
    }
    my $fromVersion = ($dist eq 'arch' ? $dist : "$dist:$relarch");
    return "FROM $fromType/$fromVersion\n";
}

# Usage: addUniverse()
#
# Adds universe to the APT sources on ubuntu, does nothing otherwise.
#
sub addUniverse {
    $dist eq 'ubuntu' and return "RUN sed -i -s 's/ main\$/ main universe/' /etc/apt/sources.list; cat /etc/apt/sources.list\n";
    return '';
}

# Usage: refreshAndInstall('zsh gcc ...')
#
# Refreshes the package list and installs the given list of packages.
#
# There is an optional second boolean argument which, if true, will perform
# a "slim" installation that excludes recommended/suggested packages (if the
# distribution supports it).
#
sub refreshAndInstall {
    # Side note: the dnf option install_weak_deps=False only seems to have
    # appeared in fedora 23.  For fedora 22 we get a warning that is loud
    # but harmless, and so we don't worry about disabling it here.
    my $pkgs = shift;
    my $slim = shift;
    my $slimopt = '';
    if ($slim) {
        ($dist eq 'debian' or $dist eq 'ubuntu') and $slimopt = '--no-install-recommends ';
        $dist eq 'fedora' and $slimopt = '--setopt=install_weak_deps=False ';
        $dist eq 'opensuse' and $slimopt = '--no-recommends ';
    }
    ($dist eq 'debian' or $dist eq 'ubuntu') and return "RUN apt-get update && apt-get install -y $slimopt$pkgs\n";
    $dist eq 'fedora' and return "RUN dnf install -y -b --refresh $slimopt$pkgs\n";
    $dist eq 'opensuse' and return "RUN zypper refresh && zypper install -y $slimopt$pkgs\n";
    $dist eq 'arch' and return "RUN pacman --noconfirm --noprogressbar -Syy && pacman --noconfirm --noprogressbar -S $slimopt$pkgs\n";
    die;
}

# Usage: upgradeAndInstall('zsh gcc ...')
#
# Refreshes the package list, upgrades all currently installed packages, and
# then installs the given list of packages.
#
# There is an optional second boolean argument which, if true, will perform
# a "slim" installation that excludes recommended/suggested packages (if the
# distribution supports it).
#
sub upgradeAndInstall {
    my $pkgs = shift;
    my $slim = shift;
    my $slimopt = '';
    if ($slim) {
        ($dist eq 'debian' or $dist eq 'ubuntu') and $slimopt = '--no-install-recommends ';
        $dist eq 'fedora' and $slimopt = '--setopt=install_weak_deps=False ';
        $dist eq 'opensuse' and $slimopt = '--no-recommends ';
    }
    ($dist eq 'debian' or $dist eq 'ubuntu') and return "RUN apt-get update && apt-get dist-upgrade -y && apt-get install -y $slimopt$pkgs\n";
    $dist eq 'fedora' and return "RUN dnf upgrade -y -b --refresh $slimopt&& dnf install -y -b $slimopt$pkgs\n";
    $dist eq 'opensuse' and return "RUN zypper refresh && zypper update -y && zypper install -y $slimopt$pkgs\n";
    $dist eq 'arch' and return "RUN pacman --noconfirm --noprogressbar -Syy && pacman --noconfirm --noprogressbar -Syu && pacman --noconfirm --noprogressbar -S $slimopt$pkgs\n";
    die;
}

# Usage: addUser('username')
#
# Adds a new ordinary user with the given username.
#
sub addUser {
    my $username = shift;
    if ($dist eq 'debian' and debianCmp('etch') <= 0) {
        return "RUN groupadd $username && useradd -s /bin/bash -m $username -g $username\n";
    } else {
        return "RUN useradd -U -s /bin/bash -m $username\n";
    }
}

# Usage: copyAndRunCommand('command', 'file1', ...)
#
# Copies all files given in the second and later arguments from this directory
# into the VM, then runs the given command in the shell within the VM, and then
# deletes the copied files from the VM.
#
sub copyAndRunCommand {
    my $command = shift;

    my @toAdd = ();
    while (my $arg = shift) {
        -e $arg or die "Missing supporting file: $arg";
        copy($arg, "$context/$arg") or die;
        push @toAdd, $arg;
    }

    my $ans = '';
    $ans .= "ADD $_ /root/$_\n" foreach (@toAdd);
    $ans .= "RUN $command && rm";
    $ans .= " /root/$_" foreach (@toAdd);
    $ans .= "\n";
    return $ans;
}

# Usage: copyAndRun('script', 'perl')
#
# Copies the given script from this directory into the VM, runs it in the VM,
# and then deletes from the VM.
#
# The second argument, if present, is the interpreter to use to run the script.
# If absent, the script is assumed to be executable and will be run directly.
#
# There may be additional arguments (third and beyond), representing other
# supporting files in this directory.  These will also be copied into the VM
# before the script is run, and deleted from the VM after the script is run.
#
sub copyAndRun {
    my $script = shift;
    my $interpreter = shift;

    -e $script or die;
    copy($script, "$context/$script") or die;
    my @toAdd = ($script);

    while (my $arg = shift) {
        -e $arg or die "Missing supporting file: $arg";
        copy($arg, "$context/$arg") or die;
        push @toAdd, $arg;
    }

    my $ans = '';
    $ans .= "ADD $_ /root/$_\n" foreach (@toAdd);
    $ans .= ($interpreter ? "RUN $interpreter " : 'RUN ');
    $ans .= "/root/$script && rm";
    $ans .= " /root/$_" foreach (@toAdd);
    $ans .= "\n";
    return $ans;
}

# Usage: addRepo('https://.../foo.repo')
#
# Adds the given repository to the package management system.
# The repository should either be an URL (for RPM-based distributions), or an
# apt-line (for debian and ubuntu).  Arch and fedora are not (yet) supported.
#
# The package listings will _not_ be refreshed.
#
sub addRepo {
    my $repo = shift;
    my $ans = '';
    if (debStyle()) {
        $hasAddedRepo or $ans = "RUN apt-get install -y --no-install-recommends software-properties-common\n";
        $ans .= "RUN apt-add-repository -y '$repo' && cat /etc/apt/sources.list\n";
    } elsif ($dist eq 'opensuse') {
        $ans .= "RUN zypper addrepo '$repo' && zypper repos\n";
    } else {
        die;
    }
    $hasAddedRepo = 1;
    return $ans;
}

# Usage: removeRepo('deb https://...')
#
# Removes the given repository from the given package management system.
# The same repository _must_ have been added earlier by addRepo().
# Currently this is only supported for debian and ubuntu.
#
# The package listings will _not_ be refreshed.
#
sub removeRepo {
    my $repo = shift;
    if (debStyle()) {
        return "RUN apt-add-repository -yr '$repo' && cat /etc/apt/sources.list\n";
    } else {
        die;
    }
}

# Usage: cleanup()
#
# Clears the package manager cache.
#
sub cleanup {
    ($dist eq 'debian' or $dist eq 'ubuntu') and return "RUN apt-get clean\n";
    $dist eq 'fedora' and return "RUN dnf clean all\n";
    $dist eq 'opensuse' and return "RUN zypper clean\n";
    $dist eq 'arch' and return "RUN yes | pacman --noprogressbar -Scc\n";
    die;
}

# --------------------------------------------------------------------------
# Basic user image
# --------------------------------------------------------------------------

sub basic {
    print("Basic user image for $dist $release\n");

    my $bare = ($dist eq 'arch' || $release eq 'sid' ? 'rolling' : 'bare');
    my $pkgs = 'ca-certificates zsh wget';
    debStyle() and debianCmp('etch') > 0 and $pkgs .= ' apt-transport-https';
    $pkgs .= ($dist eq 'fedora' ? ' gnupg2' : $dist eq 'opensuse' ? ' gpg2' :
        ' gnupg');
    debStyle() or $pkgs .= ' which perl';
    $pkgs .= ($dist eq 'fedora' ? ' vim-enhanced' : ' vim');

    my $data = from('bare');
    $data .= upgradeAndInstall($pkgs);
    $data .= cleanup();
    $data .= addUser('user');

    # For newer openSUSE packages, as we bring in more and more packages
    # (especially GUI/desktop packages), we start to see things being signed
    # with the openSUSE backports keys.  Might as well add these keys now.
    $dist eq 'opensuse' and $data .= copyAndRunCommand('rpmkeys --import /root/opensuse-backports.key', 'opensuse-backports.key');

    # For older distributions we need new root certificates just to download
    # packages from our own repositories.  For fedora, we fix this now.
    # For the oldest debian/ubuntu distributions we have a similar problem,
    # but we do not try to install newer certificates because we then just
    # run into different problems involving a too-old libssl.  Instead we just
    # put our own repositories under http://..., not https://... .
    $dist eq 'fedora' and $release <= 24 and $data .= copyAndRun('certificates-fedora.sh', 'bash');

    return $data;
}

# --------------------------------------------------------------------------
# Full desktop image
# --------------------------------------------------------------------------

sub desktop {
    print("Full desktop image for $dist $release\n");

    # For now, we do not support desktop images on openSUSE.
    # They are problematic because: (i) they are *enormous*; (ii) the package
    # installation includes long waits whilst trying to connect to services
    # that are not running since we are in a VM; and (iii) there are many
    # NOKEY errors because many of the packages used are signed with the
    # openSUSE backports key (8A49EB0325DB7AE0).
    #
    # Regarding (i): we could slim things down by only installing
    # patterns-kde-kde_plasma, but this seems to eject too much.  Not sure
    # what the sensible compromise is (or if openSUSE even offers one).
    # Regarding (iii): we could just trust the backports signing key, but I'm
    # not convinced it's a good idea to accept backports in general for these
    # docker images - openSUSE has a history of package updates messing up
    # build environments, and this is not something I want to babysit.
    #
    $dist eq 'opensuse' and return undef;

    my $data = from('basic');
    if ($dist eq 'debian') {
        $data .= upgradeAndInstall('task-gnome-desktop');
    } elsif ($dist eq 'ubuntu') {
        $data .= upgradeAndInstall('ubuntu-desktop');
    } elsif ($dist eq 'fedora') {
        $data .= "RUN dnf upgrade -y -b --refresh && dnf group install -y -b GNOME\n";
    } elsif ($dist eq 'opensuse') {
        $data .= upgradeAndInstall('patterns-kde-kde');
    } elsif ($dist eq 'arch') {
        $data .= upgradeAndInstall('gnome');
    } else {
        die;
    }
    $data .= cleanup();
    return $data;
}

# --------------------------------------------------------------------------
# General development machine
# --------------------------------------------------------------------------

sub pkgdev {
    print("Package development for $dist $release\n");

    my $purpose = shift;
    if (defined $purpose) {
        print("Tailed for building $purpose\n");

        my $data = from('pkgdev');
        my $pkgs;

        if ($purpose eq 'doxygen') {
            $dist eq 'opensuse' or
                die 'pkgdev-doxygen only supported for opensuse';
            $data .= refreshAndInstall('bison cmake flex', 1);
        } elsif ($purpose eq 'tokyocabinet') {
            $dist eq 'opensuse' or
                die 'pkgdev-tokyocabinet only supported for opensuse';
            $data .= refreshAndInstall('autoconf automake libbz2-devel libltdl7 libtool m4 site-config zlib-devel', 1);
        } else {
            die 'Unknown pkgdev-* type';
        }

        $data .= cleanup();
        return $data;
    }

    my $pkgs = 'git gdb';
    debStyle() and $pkgs .= ' build-essential devscripts fakeroot lintian autopkgtest debhelper';
    rpmStyle() and $pkgs .= ' rpm-build gcc gcc-c++';
    $dist eq 'arch' and $pkgs .= ' base-devel devtools namcap';
    $dist eq 'opensuse' and $pkgs .= ' appstream-glib';
    $dist eq 'fedora' and $pkgs .= ' libappstream-glib-builder make';
    $dist eq 'fedora' and $release >= 26 and $pkgs .= ' dnf-utils';

    # Add additional non-default compilers:
    # - For debian and LTS ubuntu releases, include all available versions of
    #   gcc and clang, so we can test different compiler versions as necessary.
    # - For openSUSE, add a modern compiler because the defaults are _ancient_.
    if ($dist eq 'debian') {
        my @gcc = ();
        $release eq 'woody' and @gcc = qw(2.95 3.0);
        $release eq 'sarge' and @gcc = qw(2.95 3.3 3.4);
        $release eq 'etch' and @gcc = qw(2.95 3.3 3.4 4.1);
        $release eq 'lenny' and @gcc = qw(4.1 4.2 4.3);
        $release eq 'squeeze' and @gcc = qw(4.3 4.4);
        $release eq 'wheezy' and @gcc = qw(4.4 4.6 4.7);
        $release eq 'jessie' and @gcc = qw(4.8 4.9);
        $release eq 'stretch' and @gcc = qw(6);
        $release eq 'buster' and @gcc = qw(7 8);
        $release eq 'bullseye' and @gcc = qw(9 10);
        $release eq 'bookworm' and @gcc = qw(11 12);
        $pkgs .= " gcc-$_ g++-$_" foreach @gcc;

        my @clang = ();
        $release eq 'jessie' and @clang = qw(3.4 3.5);
        $release eq 'stretch' and @clang = qw(3.8 3.9 4.0 7);
        $release eq 'buster' and @clang = qw(6.0 7 11 13);
        $release eq 'bullseye' and @clang = qw(9 11 13);
        $release eq 'bookworm' and @clang = qw(13 14 15);
        $pkgs .= " clang-$_" foreach @clang;
        # These releases just had a "clang" package, without versions.
        ($release eq 'squeeze' or $release eq 'wheezy') and $pkgs .= ' clang';
    } elsif ($dist eq 'ubuntu') {
        # Note: the non-standard compiler versions require universe.
        #
        # Moreover, on arm64 (where trusty is the oldest ubuntu LTS we get),
        # the trusty port does not actually _have_ these extra compilers.
        # (I should check, maybe that port did not include universe at all?)
        my @gcc = ();
        $release eq 'precise' and @gcc = qw(4.4 4.5 4.6);
        $release eq 'trusty' and $usearch ne 'aarch64' and
            @gcc = qw(4.4 4.6 4.7 4.8);
        $release eq 'xenial' and @gcc = qw(4.7 4.8 4.9 5);
        $release eq 'bionic' and @gcc = qw(4.8 5 6 7 8);
        $release eq 'focal' and @gcc = qw(7 8 9 10);
        $release eq 'jammy' and @gcc = qw(9 10 11 12);
        $pkgs .= " gcc-$_ g++-$_" foreach @gcc;

        my @clang = ();
        $release eq 'precise' and @clang = qw(3.4);
        # On trusty, the different clang versions conflict with one another.
        # We have to choose just one - we go with 3.3 because it's the one
        # clang version that we can't get elsewhere.
        # $release eq 'trusty' and @clang = qw(3.3 3.4 3.5 3.6 3.8 3.9);
        $release eq 'trusty' and $usearch ne 'aarch64' and @clang = qw(3.3);
        $release eq 'xenial' and @clang = qw(3.5 3.6 3.7 3.8 3.9 4.0 8);
        $release eq 'bionic' and @clang = qw(3.9 4.0 5.0 6.0 8 9 10);
        $release eq 'focal' and @clang = qw(6.0 7 8 9 10 12);
        $release eq 'jammy' and @clang = qw(11 12 13 14 15);
        $pkgs .= " clang-$_" foreach @clang;
    } elsif ($dist eq 'opensuse') {
        my $latest;
        $release eq '42.3' and $latest = '7';  # default: gcc48
        # 15.0 only ships gcc7
        $release eq '15.1' and $latest = '8';  # default: gcc7
        $release eq '15.2' and $latest = '9';  # default: gcc7
        $release eq '15.3' and $latest = '10'; # default: gcc7
        $release eq '15.4' and $latest = '11'; # default: gcc7
        $release eq '15.5' and $latest = '12'; # default: gcc7
        $latest and $pkgs .= " gcc$latest gcc$latest-c++";
    }

    my $data = from('basic');
    $data .= addUniverse(); # for non-default compilers on ubuntu

    # Add source repositories for those distros that don't have them already.
    debStyle() and $data .= copyAndRun('deb-src.pl', 'perl');
    $dist eq 'opensuse' and $data .= "RUN zypper addrepo http://download.opensuse.org/source/distribution/leap/$release/repo/oss/ source\n";

    $data .= upgradeAndInstall($pkgs, 1);
    $data .= cleanup();
    if ($release eq '37') {
        # On Fedora 37, appstream-builder (via gdk-pixbuf) cannot recognise
        # any icon formats at all.  The following line seems to fix this.
        $data .= "RUN /usr/bin/update-mime-database /usr/share/mime\n";
    }
    $data .= addUser('build');
    rpmStyle() and $data .= "RUN mkdir /home/build/rpmbuild && mkdir /home/build/rpmbuild/{SOURCES,SPECS} && chown -R build:build /home/build/rpmbuild\n";
    return $data;
}

# --------------------------------------------------------------------------
# Building Regina
# --------------------------------------------------------------------------

sub regina {
    print("Regina development for $dist $release\n");

    my $regver = shift;
    if ($regver) {
        print("Tailored for Regina $regver\n");
    } else {
        print("Tailored for current Regina development\n");
        $regver = 'current';
    }

    # Additional libraries that regina used to require:
    my $needCJP = (reginaVersionCmp($regver, '7.3') <= 0);
    my $needBoostHeadersOnly = (reginaVersionCmp($regver, '7.0') < 0 and
        reginaVersionCmp($regver, '5.1') > 0);
    my $needBoostLibs = (reginaVersionCmp($regver, '5.1') <= 0);
    my $needSourceHighlight = (reginaVersionCmp($regver, '5.0') <= 0);
    my $needMPI = (reginaVersionCmp($regver, '5.1') <= 0);

    # The highest Qt major version that this version of Regina supports:
    my $maxQt = (reginaVersionCmp($regver, '7.1') >= 0 ? 6 :
        reginaVersionCmp($regver, '5.0') >= 0 ? 5 : 4);

    # The highest Python major version that this version of Regina supports:
    my $maxPython = (reginaVersionCmp($regver, '5.1') > 0 ? 3 : 2);

    # Note: we use curl to download source tarballs.
    my $pkgs = 'curl cmake doxygen shared-mime-info';
    if (debStyle()) {
        $pkgs .= ' dh-python libgmp-dev libgraphviz-dev libtokyocabinet-dev libxml2-dev pkg-config zlib1g-dev xsltproc';
        $needCJP and $pkgs .= ' libcppunit-dev libjansson-dev libpopt-dev';
        $needBoostHeadersOnly and $pkgs .= ' libboost-dev';
        if ($needBoostLibs) {
            $pkgs .= ' libboost-python-dev';
            ($regver eq '5.0' or $regver eq '5.1') and $pkgs .= ' libboost-iostreams-dev';
            reginaVersionCmp($regver, '5.0') <= 0 and reginaVersionCmp($regver, '4.92') >= 0 and $pkgs .= ' libboost-regex-dev';
        }
        $needSourceHighlight and $pkgs .= ' libsource-highlight-dev';
        $needMPI and $pkgs .= ' mpi-default-dev';
        if ($maxPython == 2) {
            $pkgs .= ' python-dev';
        } elsif (reginaVersionCmp($regver, '7.1') < 0 and debianUbuntuCmp('buster', 'eoan') <= 0) {
            # Although debian buster supported python3, we always built regina
            # on buster using python2.  Likewise for ubuntu disco.  As for
            # eoan, this only ever saw regina 5.1, which used python2 because
            # regina 5.1 did not support python3.  Hence the debian/ubuntu
            # thresholds above.  This is only relevant for regina <= 7.0;
            # after this, python2 support was dropped completely from regina.
            $pkgs .= ' python-dev';
        } else {
            $pkgs .= ' python3-dev';
        }
        if ($maxQt <= 4 or ($dist eq 'ubuntu' and ubuntuCmp('quantal') <= 0)) {
            $pkgs .= ' libqt4-dev';
        } elsif ($maxQt <= 5 or debianUbuntuCmp('bullseye', 'impish') <= 0) {
            $pkgs .= ' qtbase5-dev libqt5svg5-dev';
        } else {
            $pkgs .= ' qt6-base-dev libqt6svg6-dev';
        }
        # This works around an issue that was specific to ubuntu jammy:
        $release eq 'jammy' and $pkgs .= ' libgl-dev';
    } elsif ($dist eq 'fedora') {
        $pkgs .= ' desktop-file-utils gmp-devel graphviz-devel libxml2-devel libxslt pkgconfig tokyocabinet-devel zlib-devel';
        $needCJP and $pkgs .= ' cppunit-devel jansson-devel popt-devel';
        ($needBoostHeadersOnly or $needBoostLibs) and $pkgs .= ' boost-devel';
        if ($maxPython == 2 or $release <= 25) {
            $pkgs .= ' python2-devel';
            $needBoostLibs and $release >= 29 and $pkgs .= ' boost-python2-devel';
        } else {
            $pkgs .= ' python3-devel';
            $needBoostLibs and $release >= 29 and $pkgs .= ' boost-python3-devel';
        }
        $needSourceHighlight and $pkgs .= ' source-highlight-devel';
        if ($maxQt <= 4) {
            $pkgs .= ' qt-devel';
        } elsif ($maxQt <= 5 or $release <= 34) {
            $pkgs .= ' qt5-qtbase-devel qt5-qtsvg-devel';
        } else {
            $pkgs .= ' qt6-qtbase-devel qt6-qtsvg-devel';
        }
    } elsif ($dist eq 'opensuse') {
        $pkgs .= ' gmp-devel graphviz-devel libbz2-devel libxml2-devel libxslt-tools pkg-config zlib-devel';
        $needCJP and $pkgs .= ' cppunit-devel libjansson-devel popt-devel';
        if ($needBoostLibs) {
            if ($release =~ /^42\./) {
                # The default boost is too old for many versions of regina.
                $pkgs .= ' boost_1_61-devel';
            } else {
                $pkgs .= ($maxPython == 2 ? ' libboost_python-devel' : ' libboost_python-py3-devel');
                ($regver eq '5.0' or $regver eq '5.1') and $pkgs .= ' libboost_iostreams-devel';
                reginaVersionCmp($regver, '5.0') <= 0 and reginaVersionCmp($regver, '4.92') >= 0 and $pkgs .= ' libboost_regex-devel';
            }
        } elsif ($needBoostHeadersOnly) {
            if ($release =~ /^42\./) {
                # The default boost is too old for many versions of regina.
                $pkgs .= ' boost_1_61-devel';
            } else {
                $pkgs .= ' boost-devel';
            }
        }
        $needSourceHighlight and $pkgs .= ' libsource-highlight-devel';
        if ($maxPython == 2 or $release =~ /^42\./) {
            $pkgs .= ' python2-devel';
        } else {
            $pkgs .= ' python3-devel';
        }
        if ($maxQt <= 4) {
            $pkgs .= ' libqt4-devel';
        } elsif ($maxQt <= 5 or ($release =~ /^42\./ or $release =~ /^15\.[0-3]$/)) {
            $pkgs .= ' libqt5-qtbase-devel libqt5-qtsvg-devel';
        } else {
            $pkgs .= ' qt6-base-devel qt6-svg-devel';
        }
        if (reginaVersionCmp($regver, '7.0') >= 0) {
            $pkgs .= ' lmdb-devel';
        } elsif ($release =~ /^42\./) {
            $pkgs .= ' libtokyocabinet-devel';
        } else {
            # The normal openSUSE 15.x repositories do not provide
            # tokyocabinet at all.  We need to fetch this from elsewhere;
            # we deal with this in a later block of code below.
        }
    } elsif ($dist eq 'arch') {
        $pkgs .= ' desktop-file-utils gmp graphviz hicolor-icon-theme libxml2 libxslt zlib';
        $needCJP and $pkgs .= ' cppunit jansson popt';
        ($needBoostHeadersOnly or $needBoostLibs) and $pkgs .= ' boost';
        $needSourceHighlight and $pkgs .= ' source-highlight';
        $pkgs .= ' python';
        if ($maxQt <= 4) {
            die 'Qt4 is no longer available on arch';
        } elsif ($maxQt <= 5) {
            $pkgs .= ' qt5-base qt5-svg';
        } else {
            $pkgs .= ' qt6-base qt6-svg';
        }
    } else {
        return undef;
    }

    my $data = from('pkgdev');
    $data .= upgradeAndInstall($pkgs, 1);

    if ($release eq 'bionic' or $release eq 'buster') {
        # These are old debian/ubuntu releases for which newer versions of
        # regina required a newer doxygen and/or cmake (via our own backports
        # repository).  Note that these backports were specific to bionic and
        # buster, and were not provided for even older debian/ubuntu releases
        # (which were only ever used with old versions of regina where this
        # did not matter).
        #
        print "NOTE: Adding backported doxygen and/or cmake for $release\n";
        $data .= "RUN apt-get install -y --no-install-recommends software-properties-common\n";
        $data .= copyAndRunCommand('apt-key add /root/regina-key.asc', 'regina-key.asc');
        my $repo = "deb https://people.debian.org/~bab/backports $release/";
        $data .= addRepo($repo);
        # Note: on buster we don't backport cmake, but in this case the extra
        # cmake in the command below is harmless.
        $data .= refreshAndInstall('doxygen cmake');
        $data .= removeRepo($repo);
    }
    if ($dist eq 'opensuse' and $release =~ /^15\./) {
        $data .= copyAndRunCommand('rpmkeys --import /root/regina-key.asc', 'regina-key.asc');
        if (reginaVersionCmp($regver, '6.1') >= 0) {
            # So.. openSUSE 15.x ships a doxygen so ancient that we cannot use
            # it with modern Regina.  This is true even for the newest
            # openSUSE 15.x, sigh.
            #
            # In the old days we would fetch a newer doxygen from the openSUSE
            # devel:tools repository.  BUT... the devel:tools repositories seem
            # to disappear once an openSUSE release is discontinued.  Moreover,
            # there was an issue with the devel:tools repository for 15.4 where
            # the new doxygen would drag in a newer libstdc++; such things could
            # possibly cause the build machine to generate runtime dependencies
            # that are uninstallable on an out-of-the-box openSUSE installation.
            #
            # So... we cut our losses and backport a newer doxygen ourselves.
            #
            print "NOTE: Adding backported doxygen for $release\n";
            $data .= addRepo("https://people.debian.org/~bab/rpm/doxygen/opensuse/$release/doxygen.repo");
            # Note the extra argument that we sneak into zypper here.
            $data .= refreshAndInstall('--allow-vendor-change doxygen', 1);
        }

        if (reginaVersionCmp($regver, '7.0') < 0) {
            # Old versions of regina needed tokyocabinet, which openSUSE 15.x
            # does not supply at all.  We need to fetch it also from our own
            # repository, which includes "forward-ports" of tokyocabinet from
            # openSUSE 42.3 to openSUSE 15.x.
            print "NOTE: Adding forward-ported tokyocabinet for $release\n";
            $data .= addRepo("https://people.debian.org/~bab/rpm/tokyocabinet/opensuse/$release/tokyocabinet.repo");
            $data .= refreshAndInstall('libtokyocabinet-devel', 1);
        }
    }

    $data .= cleanup();
    return $data;
}

# --------------------------------------------------------------------------
# Historical package archives for Regina
# --------------------------------------------------------------------------

sub archive {
    print("Archived Regina releases for $dist $release\n");

    my $data = from('basic');
    $data .= addUniverse(); # Ubuntu needs this for debian-keyring
    debStyle() and $data .= refreshAndInstall('debian-keyring', 1);

    # Set up the repository for the Regina packages.
    if (debStyle()) {
        $data .= copyAndRun('archive-deb.sh', 'bash', 'regina-key.asc');
    } elsif ($dist eq 'fedora') {
        $data .= copyAndRun('archive-fedora.sh', 'bash', 'regina-key.asc');
    } elsif ($dist eq 'opensuse') {
        $data .= copyAndRun('archive-opensuse.sh', 'bash', 'regina-key.asc');
    } else {
        # Arch is not supported for this image type.
        return undef;
    }

    $data .= upgradeAndInstall('regina-normal');
    $data .= cleanup();
    return $data;
}
